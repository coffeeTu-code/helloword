# 消息中间件



[TOC]



## 什么是消息中间件？


消息队列（Message Queue，简称MQ），其主要用于在复杂的微服务系统中进行消息通信。

通过消息中间件可以让不同的系统模块通过传递消息的方式来激活对方的事件以完成相应的操作。消息中间件本质上也算是一种队列，支持同步或异步方式来传输消息。

![MQ.jpeg](https://upload-images.jianshu.io/upload_images/14738618-7f323c88bcf8d092.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



## 消息中间件在架构中发挥了重要作用


### 2.1 系统解耦

A系统将数据发送到MQ中，哪些系统需要的话，就去消费（需要被授权）；如果哪天某个系统下线了，就取消消费。

![MQ4.jpeg](https://upload-images.jianshu.io/upload_images/14738618-5248fb46b2465c1a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


### 2.2 异步调用

同步阻塞式调用会使得调用链时间周期过长，而异步调用极大的缩短了调用链的时间。

![MQ2.jpeg](https://upload-images.jianshu.io/upload_images/14738618-ae477cb36661d50f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


### 2.3 队列缓冲

消息中间件就像一个蓄水池，可将大量请求存储下来让后台逐一处理。

![MQ3.jpeg](https://upload-images.jianshu.io/upload_images/14738618-b757d03a71db2707.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


### 2.4 削峰限流

削峰限流主要解决的是高并发的大访问量场景情况下，在服务前面加一层缓冲，由消息中间件做一层过滤，如果流量太大的话就会被舍弃一部分，其他未被舍弃的部分进入队列排队，保护了后端服务的可用性。



## 消息队列带来的一些问题


使用MQ还有很多好处，但是他也会带一些麻烦事。首先就是会降低系统的可用性，比如MQ挂了怎么办呢？所以在引入MQ之前就需要考虑之后带来的哪些问题，不能只看它的好处也需要考虑它带来的问题。比如下面列出的这些问题要如果解决：


1. 如何保证消息队列的高可用？
2. 如何保证消息不被重复消费？
3. 如何保证消息不丢失？
4. 如何保证消息的消费顺序？


### 3.1 如何保证消息队列的高可用？


如果是单机消息队列，一台机器挂了消息队列都就不用了，这是不能接受的，如果是一个消息队列群集，一台机器挂了还有其他机器能正常提供服务，所以要保证消息队列的高可用，我们就需要做消息队列集群。

以[RabbitMQ](https://www.rabbitmq.com/distributed.html)为例它有两种集群模式：

- 普通模式
- 镜像模式

**普通模式**

普通模式，RabbitMQ会同步各个节点的数据/状态，但不包括消息队列，默认情况下，消息队列驻留在一个节点上，尽管它们在所有节点上都是可见且可访问的。

在这种模式下，每个节点都有会所有节点的元数据信息，所以当发送消息到队列时，无论连接的是哪一个节点都能正确的发送，但是节点只会同步其他节点的元数据，消息队列的数据还是在一个节点上，如果这个节点挂了那就意味着发消息就会失败，无法保证消息队列的高可用。

**镜像模式**

默认情况下，RabbitMQ中Queue与Binding、Exchange不一样，它只会存于声明队列的节点中，但是可以选择使Queue跨多个节点进行镜像。

每一个镜像队列由一个Master和一个或多个镜像组成，任何队列的的操作，都会先应用到Master节点上然后传播到多个镜像节点。如果Master节点挂了，最老的镜像节点将会成为新的Master节点。


### 3.2 如何保证消息不被重复消费？


要避免这个重复消费的问题，可以在消费端引入内存、Redis、数据库来保存消息消费记录，根据消息Id来判断消息是否已经被消费过。


### 3.3 如何保证消息不丢失？


假设有订单服务和支付服务，正常流程是用户下单成功，然后向支付服务发送支付消息，这里面就涉及订单服务、支付服务、MQ的交互了，消息丢失可以分为三种情况：

- 生产者消息丢失
- MQ消息丢失
- 消费者消息丢失

**生产者消息丢失**

生产者消息丢失，可以使用本地消息表解决、消息确认/重发等方式来解决。以RabbitMQ为例，它有confirm机制，发出去的消息是否入队列，会使用回调的形式告知生产者，生产者收到消息后判断是Ack还是Nak，如果是Nak则重发消息。

此时还会有问题，如果极端情况下订单服务挂了，再次重启后消息就真丢失了，所以最好还是在生产中对消息做持久化，待订单服务恢复后使用Job重新发送消息。

**MQ消息丢失**

MQ消息丢失一般为未开启持久化，MQ挂了再次重启后消息丢失，所以应当将消息持久化到磁盘中。如果MQ收到消息后在同步到磁盘之前MQ挂了，那磁盘中也没有消息，这样还是会导致消息丢失消息，不过这只是小概率事件。

**消费者消息丢失**

消费者消息丢失，大都为开启了autoAck选项，消费者收到消息后还未完成处理，此时服务挂了，由于开启了autoAck， MQ会以为此消息已经被成功消费，将消息从队列中移除，而服务恢复过后也不会收到原来的消息了。


### 3.4 如果保证消息的消费顺序？


有些场景下要保持消息的顺序消费怎么办？比如写Log都是一条条打印出来，如果发到消息队列后出现消费顺序不一致那消息的那日志就会乱掉，给看日志的人带来不必要的麻烦。比如为了加快日志的处理速度使用三个消费都处理日志：

消费者A、B、C可能分别消费日志1、2、3，这时候就无法保证消息的处理顺序。要保证消息的消费顺序，首先让消息都发送到同一个队列，然后使用一个消费者去处理消息：

这样消息的处理速度就大大降低，要保持消息的顺序，则又想让消息的处理速度不至于太慢，可以引用本地队列：